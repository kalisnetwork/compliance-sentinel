"""Tests for vulnerability data provider."""

import pytest
import asyncio
from unittest.mock import MagicMock, AsyncMock, patch
from datetime import datetime
import httpx

from compliance_sentinel.providers.vulnerability_provider import VulnerabilityDataProvider
from compliance_sentinel.providers.data_provider import DataRequest, DataResponse
from compliance_sentinel.utils.intelligent_cache import IntelligentCache


class TestVulnerabilityDataProvider:
    """Test vulnerability data provider functionality."""
    
    @pytest.fixture
    def mock_cache_manager(self):
        """Create mock cache manager."""
        return MagicMock(spec=IntelligentCache)
    
    @pytest.fixture
    def mock_http_client(self):
        """Create mock HTTP client."""
        client = AsyncMock(spec=httpx.AsyncClient)
        
        # Default successful response
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "result": {
                "CVE_Items": [
                    {
                        "cve": {
                            "CVE_data_meta": {"ID": "CVE-2023-1234"},
                            "description": {
                                "description_data": [
                                    {"value": "Test vulnerability description"}
                                ]
                            }
                        },
                        "impact": {
                            "baseMetricV3": {
                                "cvssV3": {"baseScore": 7.5}
                            }
                        },
                        "publishedDate": "2023-01-01T00:00:00.000Z",
                        "lastModifiedDate": "2023-01-01T00:00:00.000Z"
                    }
                ]
            }
        }
        mock_response.raise_for_status.return_value = None
        client.get.return_value = mock_response
        
        return client
    
    @pytest.fixture
    def provider_config(self):
        """Create provider configuration."""
        return {
            "nvd_base_url": "https://services.nvd.nist.gov/rest/json/cves/2.0",
            "cve_base_url": "https://cve.circl.lu/api",
            "osv_base_url": "https://api.osv.dev/v1",
            "request_timeout": 30.0,
            "rate_limit": 50,
            "api_key": None
        }
    
    @pytest.fixture
    def vulnerability_provider(self, provider_config, mock_cache_manager):
        """Create vulnerability data provider."""
        return VulnerabilityDataProvider(
            config=provider_config,
            cache_manager=mock_cache_manager
        )
    
    @pytest.mark.asyncio
    async def test_provider_initialization(self, vulnerability_provider):
        """Test provider initialization."""
        result = await vulnerability_provider.initialize()
        assert result is True
        assert vulnerability_provider.name == "nvd-vulnerability-provider"
    
    @pytest.mark.asyncio
    async def test_health_check(self, vulnerability_provider, mock_http_client):
        """Test provider health check."""
        vulnerability_provider.session = mock_http_client
        
        # Mock successful health check response
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_http_client.get.return_value = mock_response
        
        result = await vulnerability_provider.health_check()
        assert result is True
    
    @pytest.mark.asyncio
    async def test_health_check_failure(self, vulnerability_provider, mock_http_client):
        """Test provider health check failure."""
        vulnerability_provider.session = mock_http_client
        
        # Mock failed health check
        mock_http_client.get.side_effect = httpx.ConnectError("Connection failed")
        
        result = await vulnerability_provider.health_check()
        assert result is False
    
    @pytest.mark.asyncio
    async def test_get_vulnerabilities_by_cve(self, vulnerability_provider, mock_http_client):
        """Test getting vulnerabilities by CVE ID."""
        vulnerability_provider.session = mock_http_client
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-2023-1234"}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is True
        assert response.data is not None
        assert len(response.data) > 0
        assert response.provider_name == "nvd-vulnerability-provider"
        
        # Verify HTTP client was called
        mock_http_client.get.assert_called()
    
    @pytest.mark.asyncio
    async def test_search_vulnerabilities(self, vulnerability_provider, mock_http_client):
        """Test searching vulnerabilities."""
        vulnerability_provider.session = mock_http_client
        
        request = DataRequest(
            request_type="search_vulnerabilities",
            parameters={"query": "apache", "limit": 10}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is True
        assert response.data is not None
        assert response.provider_name == "nvd-vulnerability-provider"
    
    @pytest.mark.asyncio
    async def test_get_latest_vulnerabilities(self, vulnerability_provider, mock_http_client):
        """Test getting latest vulnerabilities."""
        vulnerability_provider.session = mock_http_client
        
        request = DataRequest(
            request_type="get_latest_vulnerabilities",
            parameters={"limit": 20}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is True
        assert response.data is not None
        assert response.provider_name == "nvd-vulnerability-provider"
    
    @pytest.mark.asyncio
    async def test_get_vulnerabilities_by_product(self, vulnerability_provider, mock_http_client):
        """Test getting vulnerabilities by product."""
        vulnerability_provider.session = mock_http_client
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_product",
            parameters={"vendor": "apache", "product": "httpd", "version": "2.4.41"}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is True
        assert response.data is not None
        assert response.provider_name == "nvd-vulnerability-provider"
    
    @pytest.mark.asyncio
    async def test_caching_integration(self, vulnerability_provider, mock_http_client, mock_cache_manager):
        """Test caching integration."""
        vulnerability_provider.session = mock_http_client
        
        # Mock cache miss first, then hit
        mock_cache_manager.get.side_effect = [None, {"data": [{"cached": True}]}]
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-2023-1234"}
        )
        
        # First request - should hit external API and cache result
        response1 = await vulnerability_provider.get_data(request)
        assert response1.success is True
        
        # Verify cache was set
        mock_cache_manager.set.assert_called()
        
        # Second request - should use cache
        response2 = await vulnerability_provider.get_data(request)
        assert response2.success is True
        assert response2.data == [{"cached": True}]
    
    @pytest.mark.asyncio
    async def test_rate_limiting(self, vulnerability_provider, mock_http_client):
        """Test rate limiting functionality."""
        vulnerability_provider.session = mock_http_client
        vulnerability_provider.rate_limit = 2  # Very low limit for testing
        
        requests = [
            DataRequest(
                request_type="get_vulnerabilities_by_cve",
                parameters={"cve_id": f"CVE-2023-{i:04d}"}
            )
            for i in range(5)
        ]
        
        # Make multiple requests quickly
        responses = []
        for request in requests:
            response = await vulnerability_provider.get_data(request)
            responses.append(response)
        
        # All should succeed (rate limiting should delay, not fail)
        assert all(r.success for r in responses)
    
    @pytest.mark.asyncio
    async def test_error_handling(self, vulnerability_provider, mock_http_client):
        """Test error handling for failed requests."""
        vulnerability_provider.session = mock_http_client
        
        # Mock HTTP error
        mock_http_client.get.side_effect = httpx.HTTPStatusError(
            "Not found", request=MagicMock(), response=MagicMock(status_code=404)
        )
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-INVALID"}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is False
        assert response.error is not None
        assert "404" in response.error or "not found" in response.error.lower()
    
    @pytest.mark.asyncio
    async def test_timeout_handling(self, vulnerability_provider, mock_http_client):
        """Test timeout handling."""
        vulnerability_provider.session = mock_http_client
        
        # Mock timeout
        mock_http_client.get.side_effect = httpx.TimeoutException("Request timeout")
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-2023-1234"}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is False
        assert response.error is not None
        assert "timeout" in response.error.lower()
    
    @pytest.mark.asyncio
    async def test_circuit_breaker_integration(self, vulnerability_provider, mock_http_client):
        """Test circuit breaker integration."""
        vulnerability_provider.session = mock_http_client
        
        with patch('compliance_sentinel.utils.circuit_breaker.CircuitBreakerManager') as mock_cb:
            mock_cb_instance = MagicMock()
            mock_cb.return_value = mock_cb_instance
            mock_cb_instance.is_circuit_open.return_value = True
            
            request = DataRequest(
                request_type="get_vulnerabilities_by_cve",
                parameters={"cve_id": "CVE-2023-1234"}
            )
            
            response = await vulnerability_provider.get_data(request)
            
            assert response.success is False
            assert "circuit breaker" in response.error.lower()
    
    @pytest.mark.asyncio
    async def test_fallback_data_sources(self, vulnerability_provider, mock_http_client):
        """Test fallback to alternative data sources."""
        vulnerability_provider.session = mock_http_client
        
        # Mock NVD failure, CVE success
        responses = [
            httpx.HTTPStatusError("NVD failed", request=MagicMock(), response=MagicMock(status_code=500)),
            MagicMock()  # Successful CVE response
        ]
        
        cve_response_data = {
            "id": "CVE-2023-1234",
            "summary": "Test vulnerability from CVE source"
        }
        responses[1].json.return_value = cve_response_data
        responses[1].raise_for_status.return_value = None
        
        mock_http_client.get.side_effect = responses
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-2023-1234"}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        # Should succeed using fallback source
        assert response.success is True
        assert response.data is not None
    
    @pytest.mark.asyncio
    async def test_data_transformation(self, vulnerability_provider, mock_http_client):
        """Test data transformation and normalization."""
        vulnerability_provider.session = mock_http_client
        
        # Mock response with raw NVD data
        raw_nvd_data = {
            "result": {
                "CVE_Items": [
                    {
                        "cve": {
                            "CVE_data_meta": {"ID": "CVE-2023-1234"},
                            "description": {
                                "description_data": [
                                    {"value": "Raw NVD description"}
                                ]
                            }
                        },
                        "impact": {
                            "baseMetricV3": {
                                "cvssV3": {"baseScore": 8.5}
                            }
                        }
                    }
                ]
            }
        }
        
        mock_response = MagicMock()
        mock_response.json.return_value = raw_nvd_data
        mock_response.raise_for_status.return_value = None
        mock_http_client.get.return_value = mock_response
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-2023-1234"}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is True
        assert response.data is not None
        
        # Verify data was transformed to normalized format
        vuln_data = response.data[0]
        assert "id" in vuln_data
        assert "description" in vuln_data
        assert "severity_score" in vuln_data
    
    @pytest.mark.asyncio
    async def test_pagination_handling(self, vulnerability_provider, mock_http_client):
        """Test handling of paginated responses."""
        vulnerability_provider.session = mock_http_client
        
        # Mock paginated response
        page1_data = {
            "result": {
                "CVE_Items": [{"cve": {"CVE_data_meta": {"ID": f"CVE-2023-{i:04d}"}}} for i in range(20)],
                "totalResults": 50
            }
        }
        
        mock_response = MagicMock()
        mock_response.json.return_value = page1_data
        mock_response.raise_for_status.return_value = None
        mock_http_client.get.return_value = mock_response
        
        request = DataRequest(
            request_type="search_vulnerabilities",
            parameters={"query": "apache", "limit": 50}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is True
        assert response.data is not None
        # Should handle pagination to get all requested results
    
    @pytest.mark.asyncio
    async def test_api_key_authentication(self, provider_config, mock_cache_manager, mock_http_client):
        """Test API key authentication."""
        provider_config["api_key"] = "test-api-key-123"
        
        provider = VulnerabilityDataProvider(
            config=provider_config,
            cache_manager=mock_cache_manager
        )
        provider.session = mock_http_client
        
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-2023-1234"}
        )
        
        await provider.get_data(request)
        
        # Verify API key was included in request
        call_args = mock_http_client.get.call_args
        assert "headers" in call_args[1]
        # API key should be in headers (implementation specific)
    
    @pytest.mark.asyncio
    async def test_concurrent_requests(self, vulnerability_provider, mock_http_client):
        """Test handling concurrent requests."""
        vulnerability_provider.session = mock_http_client
        
        requests = [
            DataRequest(
                request_type="get_vulnerabilities_by_cve",
                parameters={"cve_id": f"CVE-2023-{i:04d}"}
            )
            for i in range(10)
        ]
        
        # Execute requests concurrently
        tasks = [vulnerability_provider.get_data(req) for req in requests]
        responses = await asyncio.gather(*tasks)
        
        # All should succeed
        assert len(responses) == 10
        assert all(r.success for r in responses)
    
    @pytest.mark.asyncio
    async def test_invalid_request_type(self, vulnerability_provider):
        """Test handling of invalid request types."""
        request = DataRequest(
            request_type="invalid_request_type",
            parameters={"param": "value"}
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is False
        assert response.error is not None
        assert "unsupported" in response.error.lower() or "invalid" in response.error.lower()
    
    @pytest.mark.asyncio
    async def test_missing_parameters(self, vulnerability_provider):
        """Test handling of missing required parameters."""
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={}  # Missing cve_id
        )
        
        response = await vulnerability_provider.get_data(request)
        
        assert response.success is False
        assert response.error is not None
        assert "required" in response.error.lower() or "missing" in response.error.lower()
    
    @pytest.mark.asyncio
    async def test_metrics_collection(self, vulnerability_provider, mock_http_client):
        """Test that metrics are collected during operations."""
        vulnerability_provider.session = mock_http_client
        
        with patch('compliance_sentinel.monitoring.real_time_metrics.get_metrics') as mock_metrics:
            mock_metrics_instance = MagicMock()
            mock_metrics.return_value = mock_metrics_instance
            
            request = DataRequest(
                request_type="get_vulnerabilities_by_cve",
                parameters={"cve_id": "CVE-2023-1234"}
            )
            
            await vulnerability_provider.get_data(request)
            
            # Verify metrics were recorded
            assert mock_metrics_instance.increment_counter.called
            assert mock_metrics_instance.record_timer.called
    
    def test_provider_configuration(self, vulnerability_provider):
        """Test provider configuration properties."""
        assert vulnerability_provider.nvd_base_url == "https://services.nvd.nist.gov/rest/json/cves/2.0"
        assert vulnerability_provider.cve_base_url == "https://cve.circl.lu/api"
        assert vulnerability_provider.osv_base_url == "https://api.osv.dev/v1"
        assert vulnerability_provider.request_timeout == 30.0
        assert vulnerability_provider.rate_limit == 50
    
    @pytest.mark.asyncio
    async def test_provider_cleanup(self, vulnerability_provider, mock_http_client):
        """Test provider cleanup and resource management."""
        vulnerability_provider.session = mock_http_client
        
        # Perform some operations
        request = DataRequest(
            request_type="get_vulnerabilities_by_cve",
            parameters={"cve_id": "CVE-2023-1234"}
        )
        await vulnerability_provider.get_data(request)
        
        # Cleanup
        await vulnerability_provider.cleanup()
        
        # Verify HTTP client was closed
        mock_http_client.aclose.assert_called()


class TestVulnerabilityDataTransformation:
    """Test vulnerability data transformation and normalization."""
    
    def test_nvd_data_transformation(self):
        """Test transformation of NVD data format."""
        from compliance_sentinel.providers.vulnerability_provider import VulnerabilityDataProvider
        
        raw_nvd_item = {
            "cve": {
                "CVE_data_meta": {"ID": "CVE-2023-1234"},
                "description": {
                    "description_data": [
                        {"value": "Test vulnerability description"}
                    ]
                }
            },
            "impact": {
                "baseMetricV3": {
                    "cvssV3": {"baseScore": 7.5}
                }
            },
            "publishedDate": "2023-01-01T00:00:00.000Z",
            "lastModifiedDate": "2023-01-02T00:00:00.000Z"
        }
        
        transformed = VulnerabilityDataProvider._transform_nvd_item(raw_nvd_item)
        
        assert transformed["id"] == "CVE-2023-1234"
        assert transformed["description"] == "Test vulnerability description"
        assert transformed["severity_score"] == 7.5
        assert "published_date" in transformed
        assert "last_modified_date" in transformed
    
    def test_cve_data_transformation(self):
        """Test transformation of CVE CIRCL data format."""
        from compliance_sentinel.providers.vulnerability_provider import VulnerabilityDataProvider
        
        raw_cve_item = {
            "id": "CVE-2023-1234",
            "summary": "Test vulnerability summary",
            "cvss": 8.0,
            "Published": "2023-01-01",
            "Modified": "2023-01-02"
        }
        
        transformed = VulnerabilityDataProvider._transform_cve_item(raw_cve_item)
        
        assert transformed["id"] == "CVE-2023-1234"
        assert transformed["description"] == "Test vulnerability summary"
        assert transformed["severity_score"] == 8.0
        assert "published_date" in transformed
        assert "last_modified_date" in transformed
    
    def test_osv_data_transformation(self):
        """Test transformation of OSV data format."""
        from compliance_sentinel.providers.vulnerability_provider import VulnerabilityDataProvider
        
        raw_osv_item = {
            "id": "GHSA-1234-5678-9012",
            "summary": "Test OSV vulnerability",
            "severity": [
                {
                    "type": "CVSS_V3",
                    "score": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
                }
            ],
            "published": "2023-01-01T00:00:00Z",
            "modified": "2023-01-02T00:00:00Z"
        }
        
        transformed = VulnerabilityDataProvider._transform_osv_item(raw_osv_item)
        
        assert transformed["id"] == "GHSA-1234-5678-9012"
        assert transformed["description"] == "Test OSV vulnerability"
        assert "severity_score" in transformed
        assert "published_date" in transformed
        assert "last_modified_date" in transformed


if __name__ == "__main__":
    pytest.main([__file__])