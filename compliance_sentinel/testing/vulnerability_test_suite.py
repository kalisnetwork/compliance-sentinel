"""Multi-language vulnerability test suite with real-world examples."""

import logging
import time
from typing import Dict, List, Optional, Any, Callable, Set
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import hashlib
import json

from compliance_sentinel.core.interfaces import SecurityIssue, Severity


logger = logging.getLogger(__name__)


class TestSeverity(Enum):
    """Test severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class TestStatus(Enum):
    """Test execution status."""
    PASSED = "passed"
    FAILED = "failed"
    SKIPPED = "skipped"
    ERROR = "error"


@dataclass
class VulnerabilityTest:
    """Represents a vulnerability test case."""
    
    test_id: str
    name: str
    description: str
    language: str
    vulnerability_type: str
    severity: TestSeverity
    
    # Test code samples
    vulnerable_code: str
    secure_code: str
    
    # Expected results
    expected_issues: List[str] = field(default_factory=list)
    expected_severity: Optional[Severity] = None
    
    # Test metadata
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    tags: Set[str] = field(default_factory=set)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert test to dictionary."""
        return {
            'test_id': self.test_id,
            'name': self.name,
            'description': self.description,
            'language': self.language,
            'vulnerability_type': self.vulnerability_type,
            'severity': self.severity.value,
            'cwe_id': self.cwe_id,
            'owasp_category': self.owasp_category,
            'tags': list(self.tags),
            'expected_issues_count': len(self.expected_issues)
        }


@dataclass
class TestResult:
    """Result of vulnerability test execution."""
    
    test_id: str
    status: TestStatus
    
    # Analysis results
    detected_issues: List[SecurityIssue] = field(default_factory=list)
    analysis_time: float = 0.0
    
    # Validation results
    true_positives: int = 0
    false_positives: int = 0
    false_negatives: int = 0
    
    # Error information
    error_message: Optional[str] = None
    
    # Execution metadata
    executed_at: datetime = field(default_factory=datetime.now)
    analyzer_version: str = ""
    
    @property
    def precision(self) -> float:
        """Calculate precision (TP / (TP + FP))."""
        total_positive = self.true_positives + self.false_positives
        return self.true_positives / total_positive if total_positive > 0 else 0.0
    
    @property
    def recall(self) -> float:
        """Calculate recall (TP / (TP + FN))."""
        total_actual = self.true_positives + self.false_negatives
        return self.true_positives / total_actual if total_actual > 0 else 0.0
    
    @property
    def f1_score(self) -> float:
        """Calculate F1 score."""
        p, r = self.precision, self.recall
        return 2 * (p * r) / (p + r) if (p + r) > 0 else 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert result to dictionary."""
        return {
            'test_id': self.test_id,
            'status': self.status.value,
            'detected_issues_count': len(self.detected_issues),
            'analysis_time': self.analysis_time,
            'true_positives': self.true_positives,
            'false_positives': self.false_positives,
            'false_negatives': self.false_negatives,
            'precision': self.precision,
            'recall': self.recall,
            'f1_score': self.f1_score,
            'error_message': self.error_message,
            'executed_at': self.executed_at.isoformat(),
            'analyzer_version': self.analyzer_version
        }


class VulnerabilityTestSuite:
    """Base class for vulnerability test suites."""
    
    def __init__(self, language: str, analyzer_func: Callable):
        """Initialize test suite."""
        self.language = language
        self.analyzer_func = analyzer_func
        self.tests = {}
        self.results = {}
        
        # Load test cases
        self._load_test_cases()
    
    def _load_test_cases(self):
        """Load vulnerability test cases (to be implemented by subclasses)."""
        pass
    
    def add_test(self, test: VulnerabilityTest):
        """Add a test case to the suite."""
        self.tests[test.test_id] = test
    
    def run_test(self, test_id: str) -> TestResult:
        """Run a specific test case."""
        if test_id not in self.tests:
            return TestResult(
                test_id=test_id,
                status=TestStatus.ERROR,
                error_message=f"Test {test_id} not found"
            )
        
        test = self.tests[test_id]
        start_time = time.time()
        
        try:
            # Analyze vulnerable code
            issues = self.analyzer_func(test.vulnerable_code, f"test_{test_id}.{self._get_file_extension()}")
            analysis_time = time.time() - start_time
            
            # Validate results
            result = self._validate_results(test, issues, analysis_time)
            
            self.results[test_id] = result
            return result
            
        except Exception as e:
            logger.error(f"Error running test {test_id}: {e}")
            return TestResult(
                test_id=test_id,
                status=TestStatus.ERROR,
                error_message=str(e),
                analysis_time=time.time() - start_time
            )
    
    def run_all_tests(self) -> Dict[str, TestResult]:
        """Run all test cases in the suite."""
        results = {}
        
        for test_id in self.tests:
            result = self.run_test(test_id)
            results[test_id] = result
        
        return results
    
    def _validate_results(self, test: VulnerabilityTest, issues: List[SecurityIssue], analysis_time: float) -> TestResult:
        """Validate test results against expected outcomes."""
        # Count true positives, false positives, false negatives
        detected_types = set(issue.rule_id for issue in issues)
        expected_types = set(test.expected_issues)
        
        true_positives = len(detected_types & expected_types)
        false_positives = len(detected_types - expected_types)
        false_negatives = len(expected_types - detected_types)
        
        # Determine test status
        if false_negatives == 0 and false_positives == 0:
            status = TestStatus.PASSED
        elif false_negatives > 0:
            status = TestStatus.FAILED
        else:
            status = TestStatus.PASSED  # Allow false positives but prefer fewer
        
        return TestResult(
            test_id=test.test_id,
            status=status,
            detected_issues=issues,
            analysis_time=analysis_time,
            true_positives=true_positives,
            false_positives=false_positives,
            false_negatives=false_negatives
        )
    
    def _get_file_extension(self) -> str:
        """Get file extension for the language."""
        extensions = {
            'javascript': 'js',
            'typescript': 'ts',
            'java': 'java',
            'csharp': 'cs',
            'go': 'go',
            'rust': 'rs',
            'php': 'php',
            'python': 'py'
        }
        return extensions.get(self.language.lower(), 'txt')
    
    def get_summary(self) -> Dict[str, Any]:
        """Get test suite summary."""
        if not self.results:
            return {'total_tests': len(self.tests), 'executed_tests': 0}
        
        total_tests = len(self.tests)
        executed_tests = len(self.results)
        
        passed = sum(1 for r in self.results.values() if r.status == TestStatus.PASSED)
        failed = sum(1 for r in self.results.values() if r.status == TestStatus.FAILED)
        errors = sum(1 for r in self.results.values() if r.status == TestStatus.ERROR)
        
        avg_precision = sum(r.precision for r in self.results.values()) / executed_tests if executed_tests > 0 else 0
        avg_recall = sum(r.recall for r in self.results.values()) / executed_tests if executed_tests > 0 else 0
        avg_f1 = sum(r.f1_score for r in self.results.values()) / executed_tests if executed_tests > 0 else 0
        
        return {
            'language': self.language,
            'total_tests': total_tests,
            'executed_tests': executed_tests,
            'passed': passed,
            'failed': failed,
            'errors': errors,
            'pass_rate': passed / executed_tests if executed_tests > 0 else 0,
            'average_precision': avg_precision,
            'average_recall': avg_recall,
            'average_f1_score': avg_f1
        }

class
 JavaScriptVulnerabilityTests(VulnerabilityTestSuite):
    """JavaScript/TypeScript vulnerability test suite."""
    
    def __init__(self, analyzer_func: Callable):
        """Initialize JavaScript test suite."""
        super().__init__("javascript", analyzer_func)
    
    def _load_test_cases(self):
        """Load JavaScript vulnerability test cases."""
        
        # XSS Test
        self.add_test(VulnerabilityTest(
            test_id="js_xss_dom_manipulation",
            name="DOM-based XSS",
            description="Test detection of DOM-based XSS vulnerabilities",
            language="javascript",
            vulnerability_type="xss",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
function updateContent(userInput) {
    document.getElementById('content').innerHTML = userInput;
}

function displayMessage() {
    var message = location.hash.substring(1);
    document.write(message);
}
            """,
            secure_code="""
function updateContent(userInput) {
    document.getElementById('content').textContent = userInput;
}

function displayMessage() {
    var message = location.hash.substring(1);
    document.getElementById('content').textContent = message;
}
            """,
            expected_issues=["xss_dom_manipulation", "dangerous_innerHTML"],
            cwe_id="CWE-79",
            owasp_category="A03:2021 – Injection",
            tags={"xss", "dom", "client-side"}
        ))
        
        # Prototype Pollution Test
        self.add_test(VulnerabilityTest(
            test_id="js_prototype_pollution",
            name="Prototype Pollution",
            description="Test detection of prototype pollution vulnerabilities",
            language="javascript",
            vulnerability_type="prototype_pollution",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
function merge(target, source) {
    for (let key in source) {
        if (typeof source[key] === 'object') {
            target[key] = merge(target[key] || {}, source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

function processUserData(userData) {
    let config = {};
    merge(config, JSON.parse(userData));
    return config;
}
            """,
            secure_code="""
function merge(target, source) {
    for (let key in source) {
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            continue;
        }
        if (typeof source[key] === 'object') {
            target[key] = merge(target[key] || {}, source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}
            """,
            expected_issues=["prototype_pollution", "unsafe_merge"],
            cwe_id="CWE-1321",
            tags={"prototype_pollution", "object_manipulation"}
        ))
        
        # Insecure Random Test
        self.add_test(VulnerabilityTest(
            test_id="js_weak_random",
            name="Weak Random Number Generation",
            description="Test detection of weak random number generation",
            language="javascript",
            vulnerability_type="weak_random",
            severity=TestSeverity.MEDIUM,
            vulnerable_code="""
function generateToken() {
    return Math.random().toString(36).substring(2);
}

function generateSessionId() {
    return Math.floor(Math.random() * 1000000).toString();
}
            """,
            secure_code="""
function generateToken() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}
            """,
            expected_issues=["weak_random", "insecure_math_random"],
            cwe_id="CWE-338",
            tags={"cryptography", "random", "session"}
        ))


class JavaVulnerabilityTests(VulnerabilityTestSuite):
    """Java vulnerability test suite."""
    
    def __init__(self, analyzer_func: Callable):
        """Initialize Java test suite."""
        super().__init__("java", analyzer_func)
    
    def _load_test_cases(self):
        """Load Java vulnerability test cases."""
        
        # Deserialization Test
        self.add_test(VulnerabilityTest(
            test_id="java_unsafe_deserialization",
            name="Unsafe Deserialization",
            description="Test detection of unsafe deserialization vulnerabilities",
            language="java",
            vulnerability_type="deserialization",
            severity=TestSeverity.CRITICAL,
            vulnerable_code="""
import java.io.*;

public class UserService {
    public Object deserializeUser(byte[] data) throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));
        return ois.readObject();
    }
    
    public void processUserData(String serializedData) throws Exception {
        byte[] data = Base64.getDecoder().decode(serializedData);
        Object user = deserializeUser(data);
        // Process user object
    }
}
            """,
            secure_code="""
import java.io.*;
import java.util.Set;

public class UserService {
    private static final Set<String> ALLOWED_CLASSES = Set.of(
        "com.example.User",
        "java.lang.String",
        "java.lang.Integer"
    );
    
    public Object deserializeUser(byte[] data) throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data)) {
            @Override
            protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
                if (!ALLOWED_CLASSES.contains(desc.getName())) {
                    throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
                }
                return super.resolveClass(desc);
            }
        };
        return ois.readObject();
    }
}
            """,
            expected_issues=["unsafe_deserialization", "object_input_stream"],
            cwe_id="CWE-502",
            owasp_category="A08:2021 – Software and Data Integrity Failures",
            tags={"deserialization", "rce", "object_injection"}
        ))
        
        # SQL Injection Test
        self.add_test(VulnerabilityTest(
            test_id="java_sql_injection",
            name="SQL Injection",
            description="Test detection of SQL injection vulnerabilities",
            language="java",
            vulnerability_type="sql_injection",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
import java.sql.*;

public class UserDAO {
    public User getUserById(String userId) throws SQLException {
        Connection conn = getConnection();
        String query = "SELECT * FROM users WHERE id = '" + userId + "'";
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(query);
        return mapToUser(rs);
    }
    
    public void updateUser(String userId, String name) throws SQLException {
        String sql = "UPDATE users SET name = '" + name + "' WHERE id = " + userId;
        executeUpdate(sql);
    }
}
            """,
            secure_code="""
import java.sql.*;

public class UserDAO {
    public User getUserById(String userId) throws SQLException {
        Connection conn = getConnection();
        String query = "SELECT * FROM users WHERE id = ?";
        PreparedStatement stmt = conn.prepareStatement(query);
        stmt.setString(1, userId);
        ResultSet rs = stmt.executeQuery();
        return mapToUser(rs);
    }
}
            """,
            expected_issues=["sql_injection", "string_concatenation_sql"],
            cwe_id="CWE-89",
            owasp_category="A03:2021 – Injection",
            tags={"sql_injection", "database", "injection"}
        ))


class CSharpVulnerabilityTests(VulnerabilityTestSuite):
    """C# vulnerability test suite."""
    
    def __init__(self, analyzer_func: Callable):
        """Initialize C# test suite."""
        super().__init__("csharp", analyzer_func)
    
    def _load_test_cases(self):
        """Load C# vulnerability test cases."""
        
        # Unsafe Deserialization Test
        self.add_test(VulnerabilityTest(
            test_id="csharp_binary_formatter",
            name="Unsafe BinaryFormatter Deserialization",
            description="Test detection of unsafe BinaryFormatter usage",
            language="csharp",
            vulnerability_type="deserialization",
            severity=TestSeverity.CRITICAL,
            vulnerable_code="""
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

public class UserService
{
    public object DeserializeUser(byte[] data)
    {
        BinaryFormatter formatter = new BinaryFormatter();
        using (MemoryStream stream = new MemoryStream(data))
        {
            return formatter.Deserialize(stream);
        }
    }
    
    public void ProcessUserData(string base64Data)
    {
        byte[] data = Convert.FromBase64String(base64Data);
        object user = DeserializeUser(data);
    }
}
            """,
            secure_code="""
using System;
using System.Text.Json;

public class UserService
{
    public T DeserializeUser<T>(string jsonData) where T : class
    {
        var options = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        return JsonSerializer.Deserialize<T>(jsonData, options);
    }
}
            """,
            expected_issues=["unsafe_binary_formatter", "deserialization_vulnerability"],
            cwe_id="CWE-502",
            tags={"deserialization", "binary_formatter", "rce"}
        ))
        
        # Path Traversal Test
        self.add_test(VulnerabilityTest(
            test_id="csharp_path_traversal",
            name="Path Traversal",
            description="Test detection of path traversal vulnerabilities",
            language="csharp",
            vulnerability_type="path_traversal",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
using System;
using System.IO;

public class FileService
{
    private readonly string _baseDirectory = @"C:\uploads\";
    
    public string ReadFile(string fileName)
    {
        string filePath = _baseDirectory + fileName;
        return File.ReadAllText(filePath);
    }
    
    public void SaveFile(string fileName, string content)
    {
        string fullPath = Path.Combine(_baseDirectory, fileName);
        File.WriteAllText(fullPath, content);
    }
}
            """,
            secure_code="""
using System;
using System.IO;

public class FileService
{
    private readonly string _baseDirectory = @"C:\uploads\";
    
    public string ReadFile(string fileName)
    {
        string sanitizedName = Path.GetFileName(fileName);
        string filePath = Path.Combine(_baseDirectory, sanitizedName);
        
        if (!filePath.StartsWith(_baseDirectory))
            throw new UnauthorizedAccessException("Invalid file path");
            
        return File.ReadAllText(filePath);
    }
}
            """,
            expected_issues=["path_traversal", "unsafe_file_path"],
            cwe_id="CWE-22",
            tags={"path_traversal", "file_system", "directory_traversal"}
        ))


class GoVulnerabilityTests(VulnerabilityTestSuite):
    """Go vulnerability test suite."""
    
    def __init__(self, analyzer_func: Callable):
        """Initialize Go test suite."""
        super().__init__("go", analyzer_func)
    
    def _load_test_cases(self):
        """Load Go vulnerability test cases."""
        
        # Race Condition Test
        self.add_test(VulnerabilityTest(
            test_id="go_race_condition",
            name="Race Condition",
            description="Test detection of race condition vulnerabilities",
            language="go",
            vulnerability_type="race_condition",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
package main

import (
    "fmt"
    "time"
)

var counter int

func increment() {
    for i := 0; i < 1000; i++ {
        counter++
    }
}

func main() {
    go increment()
    go increment()
    time.Sleep(time.Second)
    fmt.Println(counter)
}
            """,
            secure_code="""
package main

import (
    "fmt"
    "sync"
    "time"
)

var (
    counter int
    mutex   sync.Mutex
)

func increment() {
    for i := 0; i < 1000; i++ {
        mutex.Lock()
        counter++
        mutex.Unlock()
    }
}
            """,
            expected_issues=["race_condition", "concurrent_access"],
            cwe_id="CWE-362",
            tags={"concurrency", "race_condition", "goroutine"}
        ))
        
        # Command Injection Test
        self.add_test(VulnerabilityTest(
            test_id="go_command_injection",
            name="Command Injection",
            description="Test detection of command injection vulnerabilities",
            language="go",
            vulnerability_type="command_injection",
            severity=TestSeverity.CRITICAL,
            vulnerable_code="""
package main

import (
    "os/exec"
    "fmt"
)

func executeCommand(userInput string) error {
    cmd := exec.Command("sh", "-c", "echo " + userInput)
    output, err := cmd.Output()
    fmt.Println(string(output))
    return err
}

func processFile(filename string) error {
    cmdStr := fmt.Sprintf("cat %s | grep 'pattern'", filename)
    cmd := exec.Command("sh", "-c", cmdStr)
    return cmd.Run()
}
            """,
            secure_code="""
package main

import (
    "os/exec"
    "fmt"
    "strings"
)

func executeCommand(userInput string) error {
    // Validate and sanitize input
    if strings.ContainsAny(userInput, ";|&$`") {
        return fmt.Errorf("invalid characters in input")
    }
    
    cmd := exec.Command("echo", userInput)
    output, err := cmd.Output()
    fmt.Println(string(output))
    return err
}
            """,
            expected_issues=["command_injection", "unsafe_exec"],
            cwe_id="CWE-78",
            tags={"command_injection", "exec", "shell"}
        ))


class RustVulnerabilityTests(VulnerabilityTestSuite):
    """Rust vulnerability test suite."""
    
    def __init__(self, analyzer_func: Callable):
        """Initialize Rust test suite."""
        super().__init__("rust", analyzer_func)
    
    def _load_test_cases(self):
        """Load Rust vulnerability test cases."""
        
        # Unsafe Memory Access Test
        self.add_test(VulnerabilityTest(
            test_id="rust_unsafe_memory",
            name="Unsafe Memory Access",
            description="Test detection of unsafe memory access patterns",
            language="rust",
            vulnerability_type="memory_safety",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
use std::ptr;

fn unsafe_buffer_access(data: &[u8], index: usize) -> u8 {
    unsafe {
        *data.as_ptr().add(index)
    }
}

fn raw_pointer_manipulation() {
    let mut x = 42;
    let raw_ptr = &mut x as *mut i32;
    
    unsafe {
        *raw_ptr = 100;
        let offset_ptr = raw_ptr.add(10); // Dangerous offset
        *offset_ptr = 200;
    }
}
            """,
            secure_code="""
fn safe_buffer_access(data: &[u8], index: usize) -> Option<u8> {
    data.get(index).copied()
}

fn safe_value_update(x: &mut i32) {
    *x = 100;
}
            """,
            expected_issues=["unsafe_memory_access", "raw_pointer_arithmetic"],
            cwe_id="CWE-119",
            tags={"memory_safety", "unsafe", "buffer_overflow"}
        ))
        
        # Integer Overflow Test
        self.add_test(VulnerabilityTest(
            test_id="rust_integer_overflow",
            name="Integer Overflow",
            description="Test detection of potential integer overflow",
            language="rust",
            vulnerability_type="integer_overflow",
            severity=TestSeverity.MEDIUM,
            vulnerable_code="""
fn calculate_buffer_size(count: u32, item_size: u32) -> u32 {
    count * item_size // Potential overflow
}

fn allocate_memory(size: usize) -> Vec<u8> {
    let total_size = size + 1000; // Potential overflow
    vec![0; total_size]
}
            """,
            secure_code="""
fn calculate_buffer_size(count: u32, item_size: u32) -> Option<u32> {
    count.checked_mul(item_size)
}

fn allocate_memory(size: usize) -> Option<Vec<u8>> {
    let total_size = size.checked_add(1000)?;
    Some(vec![0; total_size])
}
            """,
            expected_issues=["integer_overflow", "unchecked_arithmetic"],
            cwe_id="CWE-190",
            tags={"integer_overflow", "arithmetic", "memory"}
        ))


class PHPVulnerabilityTests(VulnerabilityTestSuite):
    """PHP vulnerability test suite."""
    
    def __init__(self, analyzer_func: Callable):
        """Initialize PHP test suite."""
        super().__init__("php", analyzer_func)
    
    def _load_test_cases(self):
        """Load PHP vulnerability test cases."""
        
        # SQL Injection Test
        self.add_test(VulnerabilityTest(
            test_id="php_sql_injection",
            name="SQL Injection",
            description="Test detection of SQL injection vulnerabilities",
            language="php",
            vulnerability_type="sql_injection",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
<?php
class UserDAO {
    private $pdo;
    
    public function getUserById($userId) {
        $query = "SELECT * FROM users WHERE id = '" . $userId . "'";
        return $this->pdo->query($query)->fetch();
    }
    
    public function searchUsers($searchTerm) {
        $sql = "SELECT * FROM users WHERE name LIKE '%" . $_GET['search'] . "%'";
        return $this->pdo->query($sql)->fetchAll();
    }
    
    public function updateUser($id, $name) {
        $query = sprintf("UPDATE users SET name = '%s' WHERE id = %d", $name, $id);
        return $this->pdo->exec($query);
    }
}
?>
            """,
            secure_code="""
<?php
class UserDAO {
    private $pdo;
    
    public function getUserById($userId) {
        $query = "SELECT * FROM users WHERE id = ?";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([$userId]);
        return $stmt->fetch();
    }
    
    public function searchUsers($searchTerm) {
        $sql = "SELECT * FROM users WHERE name LIKE ?";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute(['%' . $searchTerm . '%']);
        return $stmt->fetchAll();
    }
}
?>
            """,
            expected_issues=["sql_injection", "string_concatenation_sql"],
            cwe_id="CWE-89",
            tags={"sql_injection", "database", "pdo"}
        ))
        
        # File Inclusion Test
        self.add_test(VulnerabilityTest(
            test_id="php_file_inclusion",
            name="Local/Remote File Inclusion",
            description="Test detection of file inclusion vulnerabilities",
            language="php",
            vulnerability_type="file_inclusion",
            severity=TestSeverity.CRITICAL,
            vulnerable_code="""
<?php
// Local File Inclusion
if (isset($_GET['page'])) {
    include $_GET['page'] . '.php';
}

// Remote File Inclusion
$template = $_POST['template'];
include $template;

// Dynamic require
function loadModule($moduleName) {
    require_once $moduleName . '.inc.php';
}

// File path from user input
$file = $_REQUEST['file'];
if (file_exists($file)) {
    readfile($file);
}
?>
            """,
            secure_code="""
<?php
$allowedPages = ['home', 'about', 'contact'];

if (isset($_GET['page']) && in_array($_GET['page'], $allowedPages)) {
    include $_GET['page'] . '.php';
}

function loadModule($moduleName) {
    $allowedModules = ['user', 'admin', 'report'];
    if (in_array($moduleName, $allowedModules)) {
        require_once $moduleName . '.inc.php';
    }
}
?>
            """,
            expected_issues=["file_inclusion", "lfi", "rfi"],
            cwe_id="CWE-98",
            tags={"file_inclusion", "lfi", "rfi", "path_traversal"}
        ))
        
        # XSS Test
        self.add_test(VulnerabilityTest(
            test_id="php_xss",
            name="Cross-Site Scripting (XSS)",
            description="Test detection of XSS vulnerabilities",
            language="php",
            vulnerability_type="xss",
            severity=TestSeverity.HIGH,
            vulnerable_code="""
<?php
// Reflected XSS
echo "Hello " . $_GET['name'];

// Stored XSS
$comment = $_POST['comment'];
echo "<div class='comment'>" . $comment . "</div>";

// XSS in attributes
$userInput = $_GET['search'];
echo "<input type='text' value='" . $userInput . "'>";

// XSS through printf
printf("Welcome %s!", $_GET['user']);
?>
            """,
            secure_code="""
<?php
// Proper escaping
echo "Hello " . htmlspecialchars($_GET['name'], ENT_QUOTES, 'UTF-8');

// Stored XSS prevention
$comment = htmlspecialchars($_POST['comment'], ENT_QUOTES, 'UTF-8');
echo "<div class='comment'>" . $comment . "</div>";

// Safe attribute values
$userInput = htmlspecialchars($_GET['search'], ENT_QUOTES, 'UTF-8');
echo "<input type='text' value='" . $userInput . "'>";
?>
            """,
            expected_issues=["xss", "unescaped_output"],
            cwe_id="CWE-79",
            tags={"xss", "output_encoding", "html_injection"}
        ))