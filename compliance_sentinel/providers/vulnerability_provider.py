"""Vulnerability data provider for real-time vulnerability information."""

import asyncio
import aiohttp
import logging
import time
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from urllib.parse import urlencode

from .data_provider import (
    CachingDataProvider, DataRequest, DataResponse, 
    HealthCheckResult, HealthStatus
)
from ..models.analysis import Severity
from ..utils.circuit_breaker import (
    CircuitBreakerConfig, CircuitBreakerOpenException, 
    get_circuit_breaker, CircuitState
)
from ..utils.resilient_error_handler import (
    get_resilient_error_handler, ErrorContext, handle_service_error, FallbackResult
)

logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """Vulnerability data model."""
    cve_id: str
    package_name: str
    affected_versions: List[str]
    severity: Severity
    cvss_score: float
    description: str
    published_date: datetime
    last_modified: datetime
    references: List[str] = field(default_factory=list)
    fix_available: bool = False
    fixed_versions: List[str] = field(default_factory=list)
    source: str = ""
    cwe_ids: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            "cve_id": self.cve_id,
            "package_name": self.package_name,
            "affected_versions": self.affected_versions,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "description": self.description,
            "published_date": self.published_date.isoformat(),
            "last_modified": self.last_modified.isoformat(),
            "references": self.references,
            "fix_available": self.fix_available,
            "fixed_versions": self.fixed_versions,
            "source": self.source,
            "cwe_ids": self.cwe_ids
        }


class NVDVulnerabilityProvider(CachingDataProvider):
    """NVD (National Vulnerability Database) vulnerability provider."""
    
    def __init__(self, config: Dict[str, Any], cache_manager=None):
        """Initialize NVD vulnerability provider."""
        super().__init__("nvd-vulnerability-provider", config, cache_manager)
        self.base_url = config.get("base_url", "https://services.nvd.nist.gov/rest/json/cves/2.0")
        self.api_key = config.get("api_key")  # Optional API key for higher rate limits
        self.timeout = config.get("timeout", 30)
        self.max_retries = config.get("max_retries", 3)
        self.rate_limit_delay = config.get("rate_limit_delay", 1.0)  # Delay between requests
        self.session: Optional[aiohttp.ClientSession] = None
        self._last_request_time = 0.0
        
        # Initialize circuit breaker
        circuit_breaker_config = CircuitBreakerConfig(
            failure_threshold=config.get("circuit_breaker_failure_threshold", 5),
            recovery_timeout=config.get("circuit_breaker_recovery_timeout", 60),
            success_threshold=config.get("circuit_breaker_success_threshold", 3),
            timeout=self.timeout,
            expected_exception_types=[aiohttp.ClientError, asyncio.TimeoutError]
        )
        self.circuit_breaker = get_circuit_breaker(f"nvd-api-{id(self)}", circuit_breaker_config)
    
    async def initialize(self, config: Dict[str, Any]) -> None:
        """Initialize NVD provider."""
        headers = {
            "User-Agent": "ComplianceSentinel/1.0 (Security Analysis Tool)"
        }
        
        if self.api_key:
            headers["apiKey"] = self.api_key
        
        timeout = aiohttp.ClientTimeout(total=self.timeout)
        self.session = aiohttp.ClientSession(
            headers=headers,
            timeout=timeout,
            connector=aiohttp.TCPConnector(limit=10)
        )
        
        logger.info(f"NVD vulnerability provider initialized with base URL: {self.base_url}")
    
    def get_supported_request_types(self) -> List[str]:
        """Get supported request types."""
        return [
            "get_vulnerabilities_by_cve",
            "search_vulnerabilities",
            "get_vulnerabilities_by_package",
            "get_recent_vulnerabilities"
        ]
    
    async def _fetch_data(self, request: DataRequest) -> DataResponse:
        """Fetch data from NVD API with resilient error handling."""
        start_time = time.time()
        error_handler = get_resilient_error_handler()
        
        # Create error context
        context = ErrorContext(
            operation=request.request_type,
            service="nvd-api",
            request_id=request.cache_key,
            metadata={
                "parameters": request.parameters,
                "priority": request.priority
            }
        )
        
        try:
            if not self.session:
                raise RuntimeError("Provider not initialized")
            
            # Rate limiting
            await self._apply_rate_limit()
            
            # Execute with resilient error handling
            async def fetch_operation():
                if request.request_type == "get_vulnerabilities_by_cve":
                    return await self._get_vulnerabilities_by_cve(request.parameters)
                elif request.request_type == "search_vulnerabilities":
                    return await self._search_vulnerabilities(request.parameters)
                elif request.request_type == "get_vulnerabilities_by_package":
                    return await self._get_vulnerabilities_by_package(request.parameters)
                elif request.request_type == "get_recent_vulnerabilities":
                    return await self._get_recent_vulnerabilities(request.parameters)
                else:
                    raise ValueError(f"Unsupported request type: {request.request_type}")
            
            # Prepare fallback data (empty vulnerability list)
            fallback_data = []
            
            # Try to execute the operation
            try:
                data = await fetch_operation()
                result = FallbackResult(success=True, data=data)
            except Exception as operation_error:
                # Handle the error with fallback strategies
                result = await error_handler.handle_external_service_error(
                    "nvd-api", operation_error, context, fallback_data
                )
            
            duration_ms = (time.time() - start_time) * 1000
            
            if result.success:
                response = DataResponse(
                    success=True,
                    data=result.data,
                    provider_name=self.name,
                    request_duration_ms=duration_ms
                )
                
                # Add fallback information to metadata
                if result.is_degraded:
                    response.metadata["fallback_used"] = True
                    if result.strategy_used:
                        response.metadata["fallback_strategy"] = result.strategy_used.value
                    response.metadata["cache_hit"] = result.cache_hit
                
                return response
            else:
                return DataResponse(
                    success=False,
                    error_message=result.error or "Unknown error",
                    provider_name=self.name,
                    request_duration_ms=duration_ms
                )
            
        except Exception as e:
            # Final fallback - handle any unexpected errors
            duration_ms = (time.time() - start_time) * 1000
            
            # Try to get fallback data from error handler
            fallback_result = await handle_service_error(
                "nvd-api", e, context, []
            )
            
            if fallback_result.success:
                return DataResponse(
                    success=True,
                    data=fallback_result.data,
                    provider_name=f"{self.name}-fallback",
                    request_duration_ms=duration_ms,
                    metadata={
                        "fallback_used": True,
                        "fallback_strategy": fallback_result.fallback_strategy.value if fallback_result.fallback_strategy else None,
                        "warnings": fallback_result.warnings
                    }
                )
            
            logger.error(f"Error fetching data from NVD: {e}")
            return DataResponse(
                success=False,
                error_message=str(e),
                provider_name=self.name,
                request_duration_ms=duration_ms
            )
    
    async def _apply_rate_limit(self) -> None:
        """Apply rate limiting to avoid overwhelming the API."""
        current_time = time.time()
        time_since_last = current_time - self._last_request_time
        
        if time_since_last < self.rate_limit_delay:
            sleep_time = self.rate_limit_delay - time_since_last
            await asyncio.sleep(sleep_time)
        
        self._last_request_time = time.time()
    
    async def _get_vulnerabilities_by_cve(self, params: Dict[str, Any]) -> List[Vulnerability]:
        """Get vulnerabilities by CVE ID."""
        cve_id = params.get("cve_id")
        if not cve_id:
            raise ValueError("cve_id parameter is required")
        
        url = f"{self.base_url}?cveId={cve_id}"
        vulnerabilities = await self._make_request(url)
        
        return [self._parse_nvd_vulnerability(vuln) for vuln in vulnerabilities.get("vulnerabilities", [])]
    
    async def _search_vulnerabilities(self, params: Dict[str, Any]) -> List[Vulnerability]:
        """Search vulnerabilities by keyword."""
        keyword = params.get("keyword", "")
        limit = params.get("limit", 20)
        
        query_params = {
            "keywordSearch": keyword,
            "resultsPerPage": min(limit, 2000)  # NVD max limit
        }
        
        # Add date filters if provided
        if "published_start_date" in params:
            query_params["pubStartDate"] = params["published_start_date"]
        if "published_end_date" in params:
            query_params["pubEndDate"] = params["published_end_date"]
        
        url = f"{self.base_url}?{urlencode(query_params)}"
        vulnerabilities = await self._make_request(url)
        
        return [self._parse_nvd_vulnerability(vuln) for vuln in vulnerabilities.get("vulnerabilities", [])]
    
    async def _get_vulnerabilities_by_package(self, params: Dict[str, Any]) -> List[Vulnerability]:
        """Get vulnerabilities for a specific package."""
        package_name = params.get("package_name")
        if not package_name:
            raise ValueError("package_name parameter is required")
        
        # Search for vulnerabilities mentioning the package name
        query_params = {
            "keywordSearch": package_name,
            "resultsPerPage": params.get("limit", 100)
        }
        
        url = f"{self.base_url}?{urlencode(query_params)}"
        vulnerabilities = await self._make_request(url)
        
        # Filter results to only include vulnerabilities actually affecting the package
        filtered_vulns = []
        for vuln_data in vulnerabilities.get("vulnerabilities", []):
            vuln = self._parse_nvd_vulnerability(vuln_data)
            if self._vulnerability_affects_package(vuln, package_name):
                vuln.package_name = package_name
                filtered_vulns.append(vuln)
        
        return filtered_vulns
    
    async def _get_recent_vulnerabilities(self, params: Dict[str, Any]) -> List[Vulnerability]:
        """Get recently published vulnerabilities."""
        days_back = params.get("days_back", 7)
        limit = params.get("limit", 50)
        
        # Calculate date range
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=days_back)
        
        query_params = {
            "pubStartDate": start_date.strftime("%Y-%m-%dT%H:%M:%S.000"),
            "pubEndDate": end_date.strftime("%Y-%m-%dT%H:%M:%S.000"),
            "resultsPerPage": min(limit, 2000)
        }
        
        url = f"{self.base_url}?{urlencode(query_params)}"
        vulnerabilities = await self._make_request(url)
        
        return [self._parse_nvd_vulnerability(vuln) for vuln in vulnerabilities.get("vulnerabilities", [])]
    
    async def _make_request(self, url: str) -> Dict[str, Any]:
        """Make HTTP request to NVD API with circuit breaker protection."""
        async def _do_request():
            async with self.session.get(url) as response:
                if response.status == 200:
                    return await response.json()
                elif response.status == 429:
                    # Rate limited - this should trigger circuit breaker
                    raise aiohttp.ClientResponseError(
                        request_info=response.request_info,
                        history=response.history,
                        status=response.status,
                        message="Rate limited by NVD API"
                    )
                else:
                    response.raise_for_status()
        
        try:
            return await self.circuit_breaker.call(_do_request)
        except CircuitBreakerOpenException as e:
            logger.warning(f"NVD API circuit breaker is open: {e}")
            raise Exception(f"NVD API temporarily unavailable (circuit breaker open). Retry after {e.retry_after} seconds")
        except Exception as e:
            logger.error(f"Error making request to NVD API: {e}")
            raise
    
    def _parse_nvd_vulnerability(self, vuln_data: Dict[str, Any]) -> Vulnerability:
        """Parse NVD vulnerability data into Vulnerability object."""
        cve = vuln_data.get("cve", {})
        cve_id = cve.get("id", "")
        
        # Parse description
        descriptions = cve.get("descriptions", [])
        description = ""
        for desc in descriptions:
            if desc.get("lang") == "en":
                description = desc.get("value", "")
                break
        
        # Parse CVSS score and severity
        cvss_score = 0.0
        severity = Severity.LOW
        
        metrics = cve.get("metrics", {})
        if "cvssMetricV31" in metrics:
            cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
            cvss_score = cvss_data.get("baseScore", 0.0)
            severity = self._cvss_to_severity(cvss_score)
        elif "cvssMetricV30" in metrics:
            cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
            cvss_score = cvss_data.get("baseScore", 0.0)
            severity = self._cvss_to_severity(cvss_score)
        elif "cvssMetricV2" in metrics:
            cvss_data = metrics["cvssMetricV2"][0]["cvssData"]
            cvss_score = cvss_data.get("baseScore", 0.0)
            severity = self._cvss_to_severity(cvss_score)
        
        # Parse dates
        published_date = datetime.fromisoformat(cve.get("published", "").replace("Z", "+00:00"))
        last_modified = datetime.fromisoformat(cve.get("lastModified", "").replace("Z", "+00:00"))
        
        # Parse references
        references = []
        for ref in cve.get("references", []):
            references.append(ref.get("url", ""))
        
        # Parse CWE IDs
        cwe_ids = []
        for weakness in cve.get("weaknesses", []):
            for desc in weakness.get("description", []):
                if desc.get("lang") == "en":
                    cwe_ids.append(desc.get("value", ""))
        
        return Vulnerability(
            cve_id=cve_id,
            package_name="",  # Will be set by caller if known
            affected_versions=[],  # NVD doesn't always have specific version info
            severity=severity,
            cvss_score=cvss_score,
            description=description,
            published_date=published_date,
            last_modified=last_modified,
            references=references,
            source="nvd",
            cwe_ids=cwe_ids
        )
    
    def _cvss_to_severity(self, cvss_score: float) -> Severity:
        """Convert CVSS score to severity level."""
        if cvss_score >= 9.0:
            return Severity.CRITICAL
        elif cvss_score >= 7.0:
            return Severity.HIGH
        elif cvss_score >= 4.0:
            return Severity.MEDIUM
        elif cvss_score > 0.0:
            return Severity.LOW
        else:
            return Severity.INFO
    
    def _vulnerability_affects_package(self, vulnerability: Vulnerability, package_name: str) -> bool:
        """Check if vulnerability affects a specific package."""
        # Simple heuristic: check if package name appears in description
        package_lower = package_name.lower()
        description_lower = vulnerability.description.lower()
        
        return (
            package_lower in description_lower or
            package_lower in vulnerability.cve_id.lower()
        )
    
    async def health_check(self) -> HealthCheckResult:
        """Check NVD API health with circuit breaker status."""
        start_time = time.time()
        
        try:
            if not self.session:
                return HealthCheckResult(
                    status=HealthStatus.UNHEALTHY,
                    message="Provider not initialized"
                )
            
            # Check circuit breaker state first
            circuit_state = self.circuit_breaker.get_state()
            circuit_stats = self.circuit_breaker.get_stats()
            
            if circuit_state == CircuitState.OPEN:
                return HealthCheckResult(
                    status=HealthStatus.UNHEALTHY,
                    message=f"NVD API circuit breaker is open (failures: {circuit_stats.current_consecutive_failures})",
                    details={
                        "circuit_breaker_state": circuit_state.value,
                        "consecutive_failures": circuit_stats.current_consecutive_failures,
                        "success_rate": circuit_stats.success_rate
                    }
                )
            
            # Make a simple request to check API availability
            test_url = f"{self.base_url}?resultsPerPage=1"
            
            try:
                result = await self.circuit_breaker.call(self._simple_health_request, test_url)
                response_time_ms = (time.time() - start_time) * 1000
                
                status = HealthStatus.HEALTHY
                message = "NVD API is accessible"
                
                if circuit_state == CircuitState.HALF_OPEN:
                    status = HealthStatus.DEGRADED
                    message = "NVD API recovering (half-open state)"
                
                return HealthCheckResult(
                    status=status,
                    message=message,
                    response_time_ms=response_time_ms,
                    details={
                        "circuit_breaker_state": circuit_state.value,
                        "success_rate": circuit_stats.success_rate,
                        "total_calls": circuit_stats.total_calls
                    }
                )
                
            except CircuitBreakerOpenException:
                response_time_ms = (time.time() - start_time) * 1000
                return HealthCheckResult(
                    status=HealthStatus.UNHEALTHY,
                    message="NVD API circuit breaker opened during health check",
                    response_time_ms=response_time_ms
                )
                    
        except Exception as e:
            response_time_ms = (time.time() - start_time) * 1000
            return HealthCheckResult(
                status=HealthStatus.UNHEALTHY,
                message=f"NVD API health check failed: {e}",
                response_time_ms=response_time_ms
            )
    
    async def _simple_health_request(self, url: str) -> bool:
        """Simple health check request."""
        async with self.session.get(url) as response:
            if response.status == 200:
                return True
            elif response.status == 429:
                raise aiohttp.ClientResponseError(
                    request_info=response.request_info,
                    history=response.history,
                    status=response.status,
                    message="Rate limited"
                )
            else:
                response.raise_for_status()
    
    async def shutdown(self) -> None:
        """Shutdown NVD provider."""
        if self.session:
            await self.session.close()
            self.session = None
        await super().shutdown()


class CVEDatabaseProvider(CachingDataProvider):
    """CVE database provider (alternative source)."""
    
    def __init__(self, config: Dict[str, Any], cache_manager=None):
        """Initialize CVE database provider."""
        super().__init__("cve-database-provider", config, cache_manager)
        self.base_url = config.get("base_url", "https://cve.circl.lu/api")
        self.timeout = config.get("timeout", 30)
        self.session: Optional[aiohttp.ClientSession] = None
        
        # Initialize circuit breaker
        circuit_breaker_config = CircuitBreakerConfig(
            failure_threshold=config.get("circuit_breaker_failure_threshold", 3),
            recovery_timeout=config.get("circuit_breaker_recovery_timeout", 30),
            success_threshold=config.get("circuit_breaker_success_threshold", 2),
            timeout=self.timeout,
            expected_exception_types=[aiohttp.ClientError, asyncio.TimeoutError]
        )
        self.circuit_breaker = get_circuit_breaker(f"cve-db-{id(self)}", circuit_breaker_config)
    
    async def initialize(self, config: Dict[str, Any]) -> None:
        """Initialize CVE database provider."""
        timeout = aiohttp.ClientTimeout(total=self.timeout)
        self.session = aiohttp.ClientSession(timeout=timeout)
        logger.info(f"CVE database provider initialized with base URL: {self.base_url}")
    
    def get_supported_request_types(self) -> List[str]:
        """Get supported request types."""
        return [
            "get_vulnerabilities_by_cve",
            "search_vulnerabilities"
        ]
    
    async def _fetch_data(self, request: DataRequest) -> DataResponse:
        """Fetch data from CVE database API."""
        start_time = time.time()
        
        try:
            if not self.session:
                raise RuntimeError("Provider not initialized")
            
            if request.request_type == "get_vulnerabilities_by_cve":
                data = await self._get_cve_by_id(request.parameters)
            elif request.request_type == "search_vulnerabilities":
                data = await self._search_cves(request.parameters)
            else:
                raise ValueError(f"Unsupported request type: {request.request_type}")
            
            duration_ms = (time.time() - start_time) * 1000
            
            return DataResponse(
                success=True,
                data=data,
                provider_name=self.name,
                request_duration_ms=duration_ms
            )
            
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(f"Error fetching data from CVE database: {e}")
            
            return DataResponse(
                success=False,
                error_message=str(e),
                provider_name=self.name,
                request_duration_ms=duration_ms
            )
    
    async def _get_cve_by_id(self, params: Dict[str, Any]) -> List[Vulnerability]:
        """Get CVE by ID with circuit breaker protection."""
        cve_id = params.get("cve_id")
        if not cve_id:
            raise ValueError("cve_id parameter is required")
        
        url = f"{self.base_url}/cve/{cve_id}"
        
        async def _do_request():
            async with self.session.get(url) as response:
                if response.status == 200:
                    cve_data = await response.json()
                    return [self._parse_cve_data(cve_data)]
                elif response.status == 404:
                    return []
                else:
                    response.raise_for_status()
        
        try:
            return await self.circuit_breaker.call(_do_request)
        except CircuitBreakerOpenException as e:
            logger.warning(f"CVE database circuit breaker is open: {e}")
            raise Exception(f"CVE database temporarily unavailable (circuit breaker open). Retry after {e.retry_after} seconds")
    
    async def _search_cves(self, params: Dict[str, Any]) -> List[Vulnerability]:
        """Search CVEs."""
        # This is a simplified implementation
        # The actual CVE database API may have different search capabilities
        keyword = params.get("keyword", "")
        
        # For now, return empty list as this would require more complex implementation
        logger.warning("CVE database search not fully implemented")
        return []
    
    def _parse_cve_data(self, cve_data: Dict[str, Any]) -> Vulnerability:
        """Parse CVE database data into Vulnerability object."""
        cve_id = cve_data.get("id", "")
        description = cve_data.get("summary", "")
        
        # Parse CVSS score
        cvss_score = float(cve_data.get("cvss", 0.0))
        severity = self._cvss_to_severity(cvss_score)
        
        # Parse dates
        published_str = cve_data.get("Published", "")
        modified_str = cve_data.get("Modified", "")
        
        try:
            published_date = datetime.fromisoformat(published_str.replace("Z", "+00:00"))
        except:
            published_date = datetime.now(timezone.utc)
        
        try:
            last_modified = datetime.fromisoformat(modified_str.replace("Z", "+00:00"))
        except:
            last_modified = datetime.now(timezone.utc)
        
        # Parse references
        references = cve_data.get("references", [])
        
        return Vulnerability(
            cve_id=cve_id,
            package_name="",
            affected_versions=[],
            severity=severity,
            cvss_score=cvss_score,
            description=description,
            published_date=published_date,
            last_modified=last_modified,
            references=references,
            source="cve-database"
        )
    
    def _cvss_to_severity(self, cvss_score: float) -> Severity:
        """Convert CVSS score to severity level."""
        if cvss_score >= 9.0:
            return Severity.CRITICAL
        elif cvss_score >= 7.0:
            return Severity.HIGH
        elif cvss_score >= 4.0:
            return Severity.MEDIUM
        elif cvss_score > 0.0:
            return Severity.LOW
        else:
            return Severity.INFO
    
    async def health_check(self) -> HealthCheckResult:
        """Check CVE database health."""
        start_time = time.time()
        
        try:
            if not self.session:
                return HealthCheckResult(
                    status=HealthStatus.UNHEALTHY,
                    message="Provider not initialized"
                )
            
            # Test with a known CVE
            test_url = f"{self.base_url}/cve/CVE-2021-44228"  # Log4j vulnerability
            
            async with self.session.get(test_url) as response:
                response_time_ms = (time.time() - start_time) * 1000
                
                if response.status == 200:
                    return HealthCheckResult(
                        status=HealthStatus.HEALTHY,
                        message="CVE database is accessible",
                        response_time_ms=response_time_ms
                    )
                else:
                    return HealthCheckResult(
                        status=HealthStatus.DEGRADED,
                        message=f"CVE database returned status {response.status}",
                        response_time_ms=response_time_ms
                    )
                    
        except Exception as e:
            response_time_ms = (time.time() - start_time) * 1000
            return HealthCheckResult(
                status=HealthStatus.UNHEALTHY,
                message=f"CVE database health check failed: {e}",
                response_time_ms=response_time_ms
            )
    
    async def shutdown(self) -> None:
        """Shutdown CVE database provider."""
        if self.session:
            await self.session.close()
            self.session = None
        await super().shutdown()


class VulnerabilityDataProvider:
    """Main vulnerability data provider that aggregates multiple sources."""
    
    def __init__(self, config: Dict[str, Any], cache_manager=None):
        """Initialize vulnerability data provider."""
        self.config = config
        self.cache_manager = cache_manager
        self.providers: List[CachingDataProvider] = []
        
        # Initialize NVD provider
        nvd_config = config.get("nvd", {})
        if nvd_config.get("enabled", True):
            self.providers.append(NVDVulnerabilityProvider(nvd_config, cache_manager))
        
        # Initialize CVE database provider
        cve_config = config.get("cve_database", {})
        if cve_config.get("enabled", False):
            self.providers.append(CVEDatabaseProvider(cve_config, cache_manager))
    
    async def initialize(self) -> None:
        """Initialize all vulnerability providers."""
        for provider in self.providers:
            await provider.initialize(provider.config)
    
    async def get_vulnerabilities(self, package: str, version: str) -> List[Vulnerability]:
        """Get vulnerabilities for specific package version."""
        request = DataRequest(
            request_type="get_vulnerabilities_by_package",
            parameters={"package_name": package, "version": version},
            cache_key=f"vulns_{package}_{version}"
        )
        
        all_vulnerabilities = []
        for provider in self.providers:
            try:
                response = await provider.get_data(request)
                if response.is_success and response.data:
                    all_vulnerabilities.extend(response.data)
            except Exception as e:
                logger.warning(f"Error getting vulnerabilities from {provider.name}: {e}")
        
        # Deduplicate by CVE ID
        seen_cves = set()
        unique_vulnerabilities = []
        for vuln in all_vulnerabilities:
            if vuln.cve_id not in seen_cves:
                seen_cves.add(vuln.cve_id)
                unique_vulnerabilities.append(vuln)
        
        return unique_vulnerabilities
    
    async def search_vulnerabilities(self, query: str) -> List[Vulnerability]:
        """Search vulnerabilities by query."""
        request = DataRequest(
            request_type="search_vulnerabilities",
            parameters={"keyword": query, "limit": 50},
            cache_key=f"search_{query}"
        )
        
        all_vulnerabilities = []
        for provider in self.providers:
            try:
                response = await provider.get_data(request)
                if response.is_success and response.data:
                    all_vulnerabilities.extend(response.data)
            except Exception as e:
                logger.warning(f"Error searching vulnerabilities from {provider.name}: {e}")
        
        return all_vulnerabilities
    
    async def shutdown(self) -> None:
        """Shutdown all providers."""
        for provider in self.providers:
            await provider.shutdown()